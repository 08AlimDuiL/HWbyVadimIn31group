## **Шпаргалка**

Простая команда UNIX с аргументами выглядит следующим образом:

***команда [опции] [другие параметры]**

(Квадратные скобки […] означают, что аргумент необязателен.)

+ Каждая конкретная команда предназначена для выполнения только одной операции. 
+ Опции указывают, как именно нужно выполнить эту операцию.
+ "Позиционные аргументы" определяют, какие именно объекты будут затронуты, например, подстроки, входные файлы или директории, и т.д.
+ Опции и позиционные аргументы вместе именуются "аргументами", т.е. это все, что следует за названием команды.
+ Опции начинаются со знака '-' (так называемые короткие опции) и со знаков '--' (длинные опции). Часто существует пара длинной и короткой опций, которые выполняют одну и ту же функцию. 

**Структура команд**

Операции с короткими опциями (т. е. начинающиеся с одиночного '-') обладают следующими удобными свойствами:

 + Порядок опций неважен. Например, последовательность -l -a эквивалентна -a -l. Это справедливо и для длинных опций.
 + Если вы работаете только с короткими опциями без значений, такими как -l и -a, то можете их соединить, упустив пробелы: -la или -al.
 + название_команды --help: выводит встроенную справку для команды; эта опция работает почти для всех команд.
 + man название_команды: выводит соответствующее команде подробное руководство, если оно установлено в системе. Мы будем изучать команду man позже, в рамках практического раздела.
 + Не меняйте местами опции и параметры, указывающие месторасположение. Например:
   + Корректная последовательность:  ls -la /tmp
   + Некорректная (может сработать, но это не гарантированно): ls /tmp -la

**Что следует запомнить, чтобы избежать ошибок:**

 + Пробелы между названием команды, секцией опций и секцией с дальнейшими аргументами обязательны. Т.е. можно выполнить "egrep -iRl что-то /some/where", но"egrep -iRlчто-то /some/where" будет неверным. Помните о пробелах в тех местах, где они необходимы всегда!
 + В мире UNIX всё является чувствительным к регистру букв. Включая названия файлов, команд, опций и имена пользователей. Например:
   + /tmp — такая директория существует, /TMP — такой директории нет.
   + Верное название команды — cat, а cAt — неверное (такой команды не существует).
   + Опции -l и -L будут иметь разное значение для одной и той же команды.
   + Существует пользователь root, но нет пользователя ROOT.

 + ```$ id``` - выводит сведения о текущем пользователе, таких как имя и числовой идентификатор. Есть опция -u.
 + ```$ uname``` - отображение сведений об операционной системе. С опцией **-a** показывает больше сведений.
 + ```$ date``` - показывает текущие дату и время;
 + ```$ date --help``` - показывает встроенную справку по применению команды;
 + ```$ ls``` - показывает содержимое текущей директории;
 + ```$ ls -l``` - показывает расширенные сведения о содержимом текущей директории; -l — это опция;
 + ```$  pwd ```  - отображение текущей рабочей директории; для этого ей не нужны опции. Pwd расшифровывается как    **print working directory** (отобразить рабочую директорию).
 + ```$  cd ```  - смена текущей рабочей директории. Расшифровывается как **change directory** (сменить директорию). Применение cd без опций вернёт вас в домашнюю директорию. cd /некий/путь — для перехода к директории /некий/путь.
 + ```$ ls ```-  отображение содержимого директории или сведений о файле. Расшифровывается как LiSt (список, перечень). 
 + ```$ ls ```(без опций) показывает содержимое текущей рабочей директории. 
 + ```$ ls -l (знак минуса и буква L в нижнем регистре)``` — то же самое плюс дополнительные сведения о содержимом. 
 + ```$ ls -l /путь/к/директории ``` — показывает расширенную информацию о содержимом директории /путь/к/директории.
 + ```$ ls -l /путь/к/файлу ``` — показывает расширенные сведения об указанном файле.
 + ```$ ls -l -d /путь/к/директории``` — показывает расширенные сведения о самой директории (НЕ о ее содержимом).
 + ``` $ cat ``` - вывод содержимого файла в терминал; не работает с директориями. Например: cat /etc/group — показывает все настройки групп операционной системы. cat /etc/passwd — показывает всех пользователей ОС. **Полезно для маленьких файлов**, неудобно для больших (представьте себе файл размером 100 МБ с 500 000 строк, перечислить которые с помощью "cat" невозможно).
      + Команда "cat" не имеет часто используемых опций, поэтому обычно она выполняется просто как cat /path/to/file

      ❗ ❗ ❗ **Примечание:** пожалуйста, помните, что "cat" не работает с директориями.

     +  Кстати, если мы выполняем
    ``` $ cat file1 file2```
      В терминале мы увидим оба этих файла, выведенные один за другим.
 + ``` $  less``` - печатает содержимое файла на терминале с использованием страниц и прокрутки. Также позволяет осуществлять строковый поиск в открытых файлах (с помощью тех же горячих клавиш, что и инструмент "man"). Чрезвычайно полезна для чтения больших файлов.
  Инструмент "less" удобен для составления списка содержимого больших файлов **(и помните, что логи могут быть огромными, поэтому для их чтения лучше использовать "less"!)**
  Лучше указывать в качестве аргумента только один файл. Как и команда "cat", "less" также обычно используется без каких-либо опций. Горячие клавиши для нее такие же, как и для команды "man", например:

    + Клавиши "Page Up" и "Page Down" можно использовать для прокрутки страницы.
    + Есть также возможность поиска по всему содержимому. Для этого нужно нажать "/", затем набрать точный шаблон для поиска, и использовать "n" для перехода к следующему вхождению, и "Shift + n" для предыдущего (аналогично Ctrl+F для графических инструментов Windows, таких как браузеры или текстовые редакторы).
    + По окончании нажмите "q" для выхода.
    + Вы можете, например, прочитать файлы /etc/passwd и /etc/group с помощью less. Это удобнее, чем "cat".
 +  ``` $ cp ``` - копирование файла или директории. Если копируемый объект — директория, то необходимо использовать опцию **-r**. Если целевой файл уже существует, то его содержимое будет перезаписано.
 + ``` $  mv cp ``` - перемещение (или переименование) файла или директории. Если целевой файл уже существует, то его содержимое будет перезаписано.
 +  ```$ egrep ``` - поиск элементов в файле или директории по указанном шаблону. Варианты: egrep какой-то_шаблон /некий/файл (для файлов), например: egrep root /etc/group; egrep -r какой-то_шаблон /некая/директория (для директорий), например: egrep -r root /tmp. Более мощная версия grep - выводит на терминал строки, соответствующие шаблонам.
  Поиск подстрок в текстовых файлах, особенно в огромных журналах (логах), которые невозможно читать и в которых невозможно искать вручную, - очень мощное средство.

Если вы хотите найти "something" в файлах, вам нужно выполнить:

  ``` $ egrep "something" file1 file2 ... fileN```

  + В позиционных параметрах может быть указано много файлов - в таких случаях команда "egrep" будет искать этот шаблон во всех из них.
   + Команда "egrep" выводит все строки, в которых найдена эта подстрока ("something" в нашем случае). Если она не найдена нигде во всех входных файлах, "egrep" ничего не выводит.
 + Например, вы можете запустить egrep bash /etc/passwd, чтобы найти и вывести все строки, содержащие "bash" в файле /etc/passwd.
 + Поведение egrep можно изменить с помощью опций, наиболее частые из которых - '-i', '-r', '-v' и '-l' (строчная буква 'L'). Их значение следующее:
   + **-i** - сделать поиск нечувствительным к регистру символов egrep -i "pattern" /some/file выведет строки, содержащие не только "pattern", но и PATTERN, pAtTeRN и т.д.
   + **-v** - вывести все строки, не соответствующие шаблону
   +  **-l** - вывести имена файлов (не строк), в которых найден данный шаблон (если таковые имеются)
   +  **-r** - поиск шаблона во всех файлах в заданном каталоге и вывод найденных совпадений строк
    + egrep -r root /etc выведет все строки из всех файлов в каталоге /etc (и его подкаталогах), содержащие подстроку "root".
 +  ```$ head ``` - выводит на терминал первые N строк из файла.
 +  ``` $ tail ``` - печатает последние N строк из файла на терминал. Также позволяет видеть изменения файла в режиме реального времени, когда программа добавляет новые строки в этот файл. Это чрезвычайно полезно, когда вы мониторите работающее приложение.
      + ``` $ tail -f input_file```
      + Все новые строки будут печататься по мере их записи в этот файл. Чтобы остановить выполнение, просто нажмите **Ctrl+C**
 +  ``` $ wc ``` - (Word Count) подсчитывает количество символов, слов и (самое полезное) строк во входных файлах.
     + ``` $  wc -l input_file  ```
     + таким образом, мы можем увидеть, сколько строк находится в указанном файле.
 +  ``` $ sort ``` - позволяет сортировать вводимые текстовые данные различными способами.
 + ``` $ uniq ``` - может удалять дублирующиеся строки, печатать только уникальные строки и показывать только дублирующиеся строки.


❗ ❗ ❗
 +  Работу с объектами файловой системы можно ускорить с помощью полезных конструкций:
    +  **..** и/или **.** (одна точка означает текущую директорию) 
    +  **~** (означает вашу домашнюю директорию).
 + **>** полностью переписывает содержимое файла
 + **>>** добавляет новые строки в файл